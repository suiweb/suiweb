import { createDomNode, updateDomNode } from './dom'
import { Fiber, isFunctionalFiber, FunctionalFiber, isStaticFiber, StaticFiber } from './fiber'
import { prepareToUseHooks } from './hooks'
import { isHTMLElement } from './utils'

/**
 * Renders the given fiber and its children to the DOM in the given container.
 * Note that all children of the container will be removed from
 * the DOM, before the fiber and its children are rendered.
 * @param fiber - The fiber which should be rendered.
 * @param container - The container in which the fiber should be rendered.
 *
 * @public
 */
export function render(fiber: Fiber, container: HTMLElement) {
    while (container.firstChild) container.firstChild?.remove()
    // No previous version is specified, as it is the first render.
    renderFiber(fiber, container)
}

/**
 * Re-renders the given {@link FunctionalFiber} inside the given container.
 * This will create a copy of the fiber tree, re-evaluate the fiber's `fiberFunction`
 * and compare the newly generated fiber tree to the old one, applying all changes to the DOM.
 * @param fiber - The fiber which should be re-rendered.
 * @param container - The container to render the fiber in.
 */
export function rerenderFunctionalFiber(fiber: FunctionalFiber, container: HTMLElement) {
    // The previous version is just a copy of the functionalFiber, which should be re-rendered.
    // This copy contains all expanded static fibers with their children -
    // the whole fiber tree below this functional fiber.
    // While rendering, the functional fiber will recompute all its children with the fiberFunction.
    // By providing this copy, the previous versions children are still retained and
    // can be compared to the new children generated by the fiberFunction.
    const previousVersion = { ...fiber }
    renderFiber(fiber, container, previousVersion)
}

/**
 * Renders the fiber and its children to the DOM. If a `previousVersion` is
 * specified, the old and the new fiber-tree are compared and only the differences
 * between the two trees are changed in the DOM.
 * @param fiber - The fiber which should be rendered.
 * @param container - The container in which the fiber should be rendered.
 * @param previousVersion - The version of the fiber before the current render.
 * Is compared to `fiber` and only the differences between the two are changed in the DOM.
 * @param nextSibling - The next sibling in the container, to keep track of the correct order inside the DOM.
 */
function renderFiber(fiber: Fiber, container: HTMLElement, previousVersion?: Fiber, nextSibling?: Fiber) {
    // If the component is a functional fiber, execute its fiberFunction
    // to get the unwrapped StaticFiber properties merged into the same object.
    if (isFunctionalFiber(fiber)) unwrapFunctionalFiber(fiber, container, previousVersion)

    // After unwrapping, the fiber must contain all properties of a static fiber.
    if (!isStaticFiber(fiber)) throw new Error('Fiber did not contain all StaticFiber properties after unwrapping.')

    // If the fiber is a placeholder, just remove the previous version, if exists.
    if (fiber.type === 'PLACEHOLDER_NODE') {
        fiber.domNode = undefined
        previousVersion?.domNode?.remove()
        return
    }

    // Determines if the new fiber still has the same type as the old fiber.
    const areSameType = fiber && previousVersion && fiber.type === previousVersion.type

    // Got a fiber with the same type in the tree, so just update the contents of the DOM node.
    if (areSameType) updateFiberInDom(fiber, container, previousVersion, nextSibling)
    // The types did not match, create new DOM node and remove previous DOM node.
    else replaceFiberInDom(fiber, container, previousVersion, nextSibling)

    expandChildFibers(fiber, previousVersion)
}

/**
 * Goes through all children of the `previousVersion` and the `fiber`.
 * If a child only exists in the `previousVersion`, it is removed from the DOM.
 * Otherwise, it calls {@link renderFiber} for every child and passes its previous version,
 * so that they can be compared and the correct adjustments in the DOM can be made.
 * @param fiber - The current version of the fiber, whose children should be expaneded.
 * @param previousVersion - The previous version of the fiber used for comparison.
 */
function expandChildFibers(fiber: StaticFiber, previousVersion?: Fiber) {
    const currentChildren = fiber.children
    const previousChildren = previousVersion?.children ?? new Map<string, Fiber>()

    // If the domNode of the container is not a HTMLElement, no children can be added to it.
    const container = fiber.domNode
    if (!container || !isHTMLElement(container)) return

    // First, remove all previousChildren from the DOM, which don't exist in the currentChildren.
    previousChildren.forEach((previousChild, key) => {
        if (currentChildren.get(key) === undefined) previousChild.domNode?.remove()
    })

    // Go through all currentChildren and render them to the DOM.
    // The previous version is passed to determine the differences between the two versions.
    // The nextChildSibling is used to enforce the correct order in the DOM.
    // The order is reversed, to determine the nextChildSibling easily (to use insertBefore API).
    let nextChildSibling: Fiber | undefined
    const reversedChildren = Array.from(currentChildren.entries()).reverse()
    reversedChildren.forEach(([key, currentChild]) => {
        const previousChild = previousChildren.get(key)
        renderFiber(currentChild, container, previousChild, nextChildSibling)
        // Placeholder nodes are not rendered, so they are not used for the order inside the container
        if (currentChild.type !== 'PLACEHOLDER_NODE') nextChildSibling = currentChild
    })
}

/**
 * Before unwrapping, a {@link FunctionalFiber} does not contain the
 * properties of a {@link StaticFiber} like `type`, `props` or `chidren`.
 * These will be only availble after unwrapping. To unwrap a {@link FunctionalFiber}
 * its `fiberFunction` is called. This process is repeated until a {@link StaticFiber}
 * is returned from the `fiberFunction`. The properties of the {@link StaticFiber} are
 * merged into the same reference of the {@link FunctionalFiber}.
 *
 * #### Hooks
 * To make the hooks work, {@link prepareToUseHooks} is called, before the `fiberFunction`
 * is executed. Additionally the `memorizedStates` array is copied from the `previousVersion`
 * so the state will not get lost.
 * @see {@link prepareToUseHooks}
 * @param fiber - The functional fiber which is unwrapped.
 * @param container - The container this fiber will be rendered in.
 * @param previousVersion - The previous version of the fiber, used to copy the `memorizedStates`.
 */
function unwrapFunctionalFiber(fiber: FunctionalFiber, container: HTMLElement, previousVersion?: Fiber) {
    // Copy memorizedStates from previousStates, or assign an empty array in case there is none
    fiber.memorizedStates = (previousVersion as FunctionalFiber)?.memorizedStates ?? []

    // Make fiber ready for hook calls.
    prepareToUseHooks(fiber.memorizedStates, () => rerenderFunctionalFiber(fiber, container))

    // Unwrap fibers until the fiberFunction returns a StaticFiber.
    let unwrappedFiber = fiber.fiberFunction(fiber.functionProps)
    while (isFunctionalFiber(unwrappedFiber))
        unwrappedFiber = unwrappedFiber.fiberFunction(unwrappedFiber.functionProps)

    // Merge all properties of the unwrappedFiber into the functional fiber.
    Object.assign(fiber, unwrappedFiber)
}

/**
 * Updates the DOM node of the `previousVersion` with the props of the new `fiber`.
 * If the order in the `container` has changed, the DOM node is reinserted at the correct position.
 */
function updateFiberInDom(fiber: StaticFiber, container: HTMLElement, previousVersion: Fiber, nextSibling?: Fiber) {
    // Get DOM node from previous version
    const domNode = previousVersion.domNode
    if (!domNode) throw new Error('Could not update fiber, previous domNode was not set.')
    fiber.domNode = domNode

    // Update all props on DOM node
    updateDomNode(domNode, previousVersion?.props, fiber.props)

    // If the order has changed, the element has to be reinserted at correct position.
    // Note that insertBefore takes care of removing the element from the DOM before
    // re-inserting it, so it's not needed to remove it manually.
    if (nextSibling && domNode.nextSibling !== nextSibling?.domNode) {
        container.insertBefore(domNode, nextSibling?.domNode ?? null)
    }
}

/**
 * Creates a new DOM node for the `fiber` and inserts it at the correct position in the `container`.
 * Removes the DOM node of the `previousVersion` from the DOM.
 */
function replaceFiberInDom(fiber: StaticFiber, container: HTMLElement, previousVersion?: Fiber, nextSibling?: Fiber) {
    // Remove DOM node of the previous version from the DOM
    previousVersion?.domNode?.remove()

    // Create DOM node for new fiber
    const newDomNode = createDomNode(fiber)
    fiber.domNode = newDomNode
    container.insertBefore(newDomNode, nextSibling?.domNode ?? null)
}

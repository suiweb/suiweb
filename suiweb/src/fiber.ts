import { isPrimitive, type Primitive } from './utils'

/**
 * A `Fiber` can be either a {@link StaticFiber} or a {@link FunctionalFiber}.
 */
export type Fiber = StaticFiber | FunctionalFiber

/**
 * A `StaticFiber` represents a static element in the DOM. It does not contain
 * a function and thus can't use hooks, so it will never trigger a re-render.
 * It is completely defined by its `type`, `props` and `children`.
 * Its `domNode` will be assigned when it is rendered to the DOM.
 */
export type StaticFiber = {
    /**
     * The type of the static fiber.
     * It is either a html tag or a custom tag for text or placeholder nodes.
     */
    type: StaticFiberType
    /**
     * The props of the static fiber. These will be added to them DOM node when it is rendered.
     * There are special props like `key` which serve their custom purpose and are not added to the DOM node.
     * @see {@link isNormalProp}
     */
    props: Readonly<Props>
    /**
     * The children of the fiber are stored in a map where every child has a unique key.
     * If no `key` is provided in the `props` of the corresponding child, a default key is used.
     */
    children: Map<string, Fiber>
    /**
     * The reference to the DOM node which this fiber represents.
     * Is only set when the fiber is rendered.
     */
    domNode?: HTMLElement | Text | undefined
}

/**
 * The possible type of a {@link StaticFiber}.
 * Fibers with type `TEXT_NODE` or `PLACEHOLDER_NODE` will not be rendered
 * to the dom directly, but are treated specially instead.
 */
export type StaticFiberType = keyof HTMLElementTagNameMap | 'TEXT_NODE' | 'PLACEHOLDER_NODE'

/**
 * Determines if an object is of type {@link StaticFiber}.
 * @param object - The object to check.
 * @returns `true` if the object is of type {@link StaticFiber}.
 */
export function isStaticFiber(object: unknown): object is StaticFiber {
    const testElement = object as StaticFiber
    return (
        testElement &&
        typeof testElement.type === 'string' &&
        typeof testElement.props === 'object' &&
        testElement.children instanceof Map
    )
}

/**
 * A `FunctionalFiber` represents an element, which is generated by a function call.
 * This generator-function is stored in the property `fiberFunction` and when the component
 * is re-rendered, the `fiberFunction` is called with `functionalProps` as argument.
 * In the `fiberFunction`, hooks can be called, whose values are stored in the `memorizedStates` array.
 *
 * #### StaticFiber Properties
 * A `FunctionalFiber` contains all properties of a {@link StaticFiber}, but only as optionals.
 * The properties `type`, `props` and `children`, which define a {@link StaticFiber},
 * are only assigned when the component is unwrapped i.e., its `fiberFunction` is called.
 * This happens during rendering, when the `fiberFunction` is called. The returned {@link StaticFiber}
 * will be merged into the `FunctionalFiber` and provide these three properties.
 */
export type FunctionalFiber = {
    /**
     * The `fiberFunction` contains the information to generate the fiber.
     * It takes the `functionProps` as an argument, calls hooks and returns the generated `Fiber`.
     */
    fiberFunction: FiberFunction
    /**
     * The `functionProps` are the props which are passed to the `fiberFunction`. Differently to the
     * normal `props`, these are not added to the DOM and only used inside of the `fiberFunction`.
     * The normal `props` will be defined by the `StaticFiber`, which will be returned from executing
     * the `fiberFunction`.
     * These will be the `props` that will be added to the DOM node.
     * @see {@link StaticFiber}
     */
    functionProps: Readonly<Props>
    /**
     * The `memorizedStates` array contains all stored values of the component's hooks.
     */
    memorizedStates: unknown[]
} & Partial<StaticFiber>

/**
 * The `FiberFunction` of a {@link FunctionalFiber}, which returns a {@link Fiber}.
 */
export type FiberFunction = (props?: Props) => Fiber

/**
 * Determines if an object is of type {@link FunctionalFiber}.
 * @param object - The object to check.
 * @returns `true` if the object is of type {@link FunctionalFiber}.
 */
export function isFunctionalFiber(object: unknown): object is FunctionalFiber {
    const testElement = object as FunctionalFiber
    return (
        testElement &&
        testElement.fiberFunction instanceof Function &&
        typeof testElement.functionProps === 'object' &&
        Array.isArray(testElement.memorizedStates)
    )
}

/**
 * The Props which a SuiWeb {@link Fiber} expects.
 */
export type Props = {
    /**
     * A unique key to differentiate the element between its siblings.
     * This should always be set when the number of elements is dynamic,
     * e.g., when using {@link Array.map} to create elements.
     */
    key?: string | number | null
    /**
     * The style of the element.
     * @see {@link StyleProp}
     */
    style?: StyleProp
    /**
     * Children must not be passed in the props, as they will be overwritten.
     * They should be specified as child elements in a represenation like `SJDON` or `JSX`.
     */
    children?: never
} & Partial<Omit<HTMLElement, 'style' | 'children'>> &
    Record<string, unknown>

/**
 * The `StyleProp` is usally passed as the `style` property of the props.
 * It can either be:
 * - a CSS string which is set directly to style attribute.
 * - an object containing CSS properties in camelCase.
 * - an array of objects containing CSS properties in camcelCase.
 */
export type StyleProp = string | Partial<CSSStyleDeclaration> | Partial<CSSStyleDeclaration>[]

/**
 * Determines if the given `propName` is a normal prop which should be directly added to
 * the DOM node, or if it serves a custom purpose.
 * Currently there are three special props, namely `children`, `style` and `key`.
 * @param propName - The name of the prop to check.
 * @returns `true` if the given prop is a normal prop.
 */
export function isNormalProp(propName: string): boolean {
    return propName !== 'style' && propName !== 'key'
}

/**
 * A function which creates elements from a `type`, `props` and `children`.
 * Can be used with SJDON, but also standards like JSX.
 * It is in the same format as the `React.createElement` function so it could possibly
 * be interchanged. But note that the typings don't match exactly,
 * e.g., `React.createElement` can't handle all values of {@link Props}.
 * @param type - The type can either be a HTML tag or a function, which returns an element.
 * @param props - The props of the element. If JSX is used instead of SJDON, it has to be made sure
 * that the "special props" like `style` or `key` overlap enough with the {@link Props}.
 * This should be the case for the properties `style` and `key`, but is not guaranteed for all props.
 * To provide basic functionality, also JSX `on<Event>` event handlers are supported.
 * @param children - The children of the element.
 * @returns The generated element.
 */
export type CreateElementFunction<T = Fiber> = (
    type: keyof HTMLElementTagNameMap | ((props?: Record<string, unknown>) => T),
    props: Props | null,
    ...children: (T | Primitive)[]
) => T

/**
 * The SuiWeb implementation of the generic {@link CreateElementFunction}, which creates a {@link Fiber}.
 * @param type - If the type is a HTML tag, a {@link StaticFiber} is created. If it's a function, a {@link FunctionalFiber} is created.
 * @param props - The props of the element.
 * @param children - The children of the element.
 * @returns The created {@link Fiber}, either a {@link StaticFiber} or a {@link FunctionalFiber}.
 *
 * @public
 */
export const createElement: CreateElementFunction<Fiber> = (type, props, ...children) => {
    const mappedChildren = mapChildren(children)
    const safeProps = props ?? {}

    // If the type is a function, create a functional fiber.
    if (type instanceof Function) {
        // A functional element can not have direct children, it is a function,
        // which can take in children as a prop and return a static element with children.
        if (mappedChildren.size > 0) throw new Error('A functional element can not have children.')

        return {
            fiberFunction: type,
            functionProps: safeProps,
            memorizedStates: [],
        }
    }
    // Otherwise create a static fiber.
    else return { type, props: safeProps, children: mappedChildren }
}

/**
 * Maps the children of an element into a `Map`. If they don't have an explicit
 * `key` set in their `props`, a default key is used to insert the object into the Map.
 * Primitive values are wrapped into {@link StaticFiber}s by {@link createPlaceholderFiber}
 * and {@link createTextFiber}, respectively.
 * @param childrenRaw - The children to map.
 * @returns The Map containing the mapped children.
 */
function mapChildren(childrenRaw: (Fiber | Primitive)[]): Map<string, Fiber> {
    const children = childrenRaw.map(child => {
        if (child == null || child === false) return createPlaceholderFiber()
        else if (isPrimitive(child)) return createTextFiber(child)
        else return child
    })

    // Use a Map to store children in, as this allows to set a custom key,
    // while also guaranteeing to preserve the order of insertion (unlike object).
    const childrenMap: Map<string, Fiber> = new Map()
    let defaultKey = 0
    children.forEach(child => {
        const childProps = isFunctionalFiber(child) ? child.functionProps : child.props
        // Keys are prefixed e-(xplicit) or d-(efault), so a custom key can never
        // accidentally match a generated key.
        const key = childProps?.key ? `e-${childProps?.key}` : `d-${defaultKey++}`
        childrenMap.set(key, child)
    })

    return childrenMap
}

/**
 * Creates a `TextFiber` wrapper element for a primitive value.
 * This allows for treating this element specially when rendering the Fibers
 * to the DOM.
 * @param text - The primitive value which should be wrapped.
 * @returns A {@link StaticFiber} with the special `type` `TEXT_NODE`.
 */
function createTextFiber(text: NonNullable<Primitive>): StaticFiber {
    return {
        type: 'TEXT_NODE',
        props: {
            nodeValue: text.toString(),
        },
        children: new Map(),
    }
}

/**
 * Creates a placeholder fiber, which represents a child of values `undefined`, `null` or `false`.
 * Placeholder fibers are never rendered to the DOM, but used to preserve
 * the correct amount of elements in a hierarchy. This is needed, for example, when components are
 * rendered conditionally.
 * @returns A {@link StaticFiber} with the special `type` `PLACEHOLDER_NODE`.
 */
function createPlaceholderFiber(): StaticFiber {
    return {
        type: 'PLACEHOLDER_NODE',
        props: {},
        children: new Map(),
    }
}

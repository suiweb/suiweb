function E(e) {
  return e == null || ["string", "number", "bigint", "boolean", "symbol"].includes(typeof e);
}
function A(e) {
  return e instanceof HTMLElement;
}
function C(e) {
  return e instanceof Text;
}
function O(e) {
  const t = e;
  return t && typeof t.type == "string" && typeof t.props == "object" && t.children instanceof Map;
}
function d(e) {
  const t = e;
  return t && t.fiberFunction instanceof Function && typeof t.functionProps == "object" && Array.isArray(t.memorizedStates);
}
function p(e) {
  return e !== "style" && e !== "key";
}
const H = (e, t, ...o) => {
  const r = S(o), n = t ?? {};
  if (e instanceof Function) {
    if (r.size > 0)
      throw new Error("A functional element can not have children.");
    return {
      fiberFunction: e,
      functionProps: n,
      memorizedStates: []
    };
  } else
    return { type: e, props: n, children: r };
};
function S(e) {
  const t = e.map((n) => n == null || n === !1 ? v() : E(n) ? N(n) : n), o = /* @__PURE__ */ new Map();
  let r = 0;
  return t.forEach((n) => {
    const i = d(n) ? n.functionProps : n.props, s = i?.key ? `e-${i?.key}` : `d-${r++}`;
    o.set(s, n);
  }), o;
}
function N(e) {
  return {
    type: "TEXT_NODE",
    props: {
      nodeValue: e.toString()
    },
    children: /* @__PURE__ */ new Map()
  };
}
function v() {
  return {
    type: "PLACEHOLDER_NODE",
    props: {},
    children: /* @__PURE__ */ new Map()
  };
}
let a, y, u = 0;
function D(e, t) {
  a = e, y = t, u = 0;
}
function R(e) {
  const t = a, o = y, r = u, n = t[r] ?? e, i = (s) => {
    t[r] = s, o();
  };
  return u++, [n, i];
}
function _(e, t) {
  let o = !1;
  t !== void 0 ? (a[u] !== !0 && (o = !0, a[u] = !0), u++) : o = !0, t?.forEach((r) => {
    r !== a[u] && (o = !0), a[u] = r, u++;
  }), o && setTimeout(e);
}
function T(e) {
  if (e.type === "PLACEHOLDER_NODE")
    throw new Error("Could not create a DOM node for the type PLACEHOLDER_NODE.");
  const t = e.type === "TEXT_NODE" ? document.createTextNode("") : document.createElement(e.type);
  return h(t, void 0, e.props), t;
}
function h(e, t = {}, o = {}) {
  if (C(e)) {
    e.nodeValue = o.nodeValue ?? "";
    return;
  }
  const r = (n) => n.startsWith("on");
  Object.keys(t).filter(r).forEach((n) => {
    const i = n.toLowerCase().substring(2), s = t[n];
    e.removeEventListener(i, s);
  }), Object.keys(o).filter(r).forEach((n) => {
    const i = n.toLowerCase().substring(2), s = o[n];
    e?.addEventListener(i, s);
  }), Object.keys(t).filter(p).forEach((n) => {
    e.removeAttribute(n);
  }), Object.keys(o).filter(p).forEach((n) => {
    const i = o[n]?.toString();
    i && e.setAttribute(n, i);
  }), b(e, o.style);
}
function b(e, t = {}) {
  const o = (r) => Object.entries(r).forEach(
    ([n, i]) => e.style[n] = i?.toString() ?? null
  );
  e.removeAttribute("style"), typeof t == "string" ? e.style.cssText = t : Array.isArray(t) ? t.forEach((r) => o(r)) : typeof t == "object" && o(t);
}
function z(e, t) {
  for (; t.firstChild; )
    t.firstChild?.remove();
  l(e, t);
}
function g(e, t) {
  const o = { ...e };
  l(e, t, o);
}
function l(e, t, o, r) {
  if (d(e) && j(e, t, o), !O(e))
    throw new Error("Fiber did not contain all StaticFiber properties after unwrapping.");
  if (e.type === "PLACEHOLDER_NODE") {
    e.domNode = void 0, o?.domNode?.remove();
    return;
  }
  e && o && e.type === o.type ? k(e, t, o, r) : M(e, t, o, r), L(e, o);
}
function L(e, t) {
  const o = e.children, r = t?.children ?? /* @__PURE__ */ new Map(), n = e.domNode;
  if (!n || !A(n))
    return;
  r.forEach((c, f) => {
    o.get(f) === void 0 && c.domNode?.remove();
  });
  let i;
  Array.from(o.entries()).reverse().forEach(([c, f]) => {
    const w = r.get(c);
    l(f, n, w, i), f.type !== "PLACEHOLDER_NODE" && (i = f);
  });
}
function j(e, t, o) {
  e.memorizedStates = o?.memorizedStates ?? [], D(e.memorizedStates, () => g(e, t));
  let r = e.fiberFunction(e.functionProps);
  for (; d(r); )
    r = r.fiberFunction(r.functionProps);
  Object.assign(e, r);
}
function k(e, t, o, r) {
  const n = o.domNode;
  if (!n)
    throw new Error("Could not update fiber, previous domNode was not set.");
  e.domNode = n, h(n, o?.props, e.props), r && n.nextSibling !== r?.domNode && t.insertBefore(n, r?.domNode ?? null);
}
function M(e, t, o, r) {
  o?.domNode?.remove();
  const n = T(e);
  e.domNode = n, t.insertBefore(n, r?.domNode ?? null);
}
function P(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function F(e) {
  return Array.isArray(e) && e.length != 0 && ["string", "function"].includes(typeof e[0]);
}
function x(e) {
  return E(e) || F(e);
}
function m([e, ...t], o) {
  const r = t.filter(P), n = Object.assign({}, ...r), i = t.filter(x);
  if (typeof e == "string") {
    const s = i.map((c) => F(c) ? m(c, o) : c);
    return o(e, n, ...s);
  } else
    return o((c) => m(e({ ...c, children: i }), o), n);
}
export {
  H as createElement,
  m as parseSjdon,
  z as render,
  _ as useEffect,
  R as useState
};

/**
 * The SuiWeb implementation of the generic {@link CreateElementFunction}, which creates a {@link Fiber}.
 * @param type - If the type is a HTML tag, a {@link StaticFiber} is created. If it's a function, a {@link FunctionalFiber} is created.
 * @param props - The props of the element.
 * @param children - The children of the element.
 * @returns The created {@link Fiber}, either a {@link StaticFiber} or a {@link FunctionalFiber}.
 *
 * @public
 */
export declare const createElement: CreateElementFunction<Fiber>;

/**
 * A function which creates elements from a `type`, `props` and `children`.
 * Can be used with SJDON, but also standards like JSX.
 * It is in the same format as the `React.createElement` function so it could possibly
 * be interchanged. But note that the typings don't match exactly,
 * e.g., `React.createElement` can't handle all values of {@link Props}.
 * @param type - The type can either be a HTML tag or a function, which returns an element.
 * @param props - The props of the element. If JSX is used instead of SJDON, it has to be made sure
 * that the "special props" like `style` or `key` overlap enough with the {@link Props}.
 * This should be the case for the properties `style` and `key`, but is not guaranteed for all props.
 * To provide basic functionality, also JSX `on<Event>` event handlers are supported.
 * @param children - The children of the element.
 * @returns The generated element.
 */
export declare type CreateElementFunction<T = Fiber> = (type: keyof HTMLElementTagNameMap | ((props?: Record<string, unknown>) => T), props: Props | null, ...children: (T | Primitive)[]) => T;

/**
 * A `Fiber` can be either a {@link StaticFiber} or a {@link FunctionalFiber}.
 */
export declare type Fiber = StaticFiber | FunctionalFiber;

/**
 * The `FiberFunction` of a {@link FunctionalFiber}, which returns a {@link Fiber}.
 */
export declare type FiberFunction = (props?: Props) => Fiber;

/**
 * A `FunctionalFiber` represents an element, which is generated by a function call.
 * This generator-function is stored in the property `fiberFunction` and when the component
 * is re-rendered, the `fiberFunction` is called with `functionalProps` as argument.
 * In the `fiberFunction`, hooks can be called, whose values are stored in the `memorizedStates` array.
 *
 * #### StaticFiber Properties
 * A `FunctionalFiber` contains all properties of a {@link StaticFiber}, but only as optionals.
 * The properties `type`, `props` and `children`, which define a {@link StaticFiber},
 * are only assigned when the component is unwrapped i.e., its `fiberFunction` is called.
 * This happens during rendering, when the `fiberFunction` is called. The returned {@link StaticFiber}
 * will be merged into the `FunctionalFiber` and provide these three properties.
 */
export declare type FunctionalFiber = {
    /**
     * The `fiberFunction` contains the information to generate the fiber.
     * It takes the `functionProps` as an argument, calls hooks and returns the generated `Fiber`.
     */
    fiberFunction: FiberFunction;
    /**
     * The `functionProps` are the props which are passed to the `fiberFunction`. Differently to the
     * normal `props`, these are not added to the DOM and only used inside of the `fiberFunction`.
     * The normal `props` will be defined by the `StaticFiber`, which will be returned from executing
     * the `fiberFunction`.
     * These will be the `props` that will be added to the DOM node.
     * @see {@link StaticFiber}
     */
    functionProps: Readonly<Props>;
    /**
     * The `memorizedStates` array contains all stored values of the component's hooks.
     */
    memorizedStates: unknown[];
} & Partial<StaticFiber>;

/**
 * Parses a {@link SjdonElement} with all its children and creates a fiber tree.
 * Uses the {@link createElement} function to create all fibers.
 * @param param0 - The {@link SjdonElement} which should be parsed.
 * @param create - The function which is used to create the elements.
 * It works properly with the SuiWeb implementation {@link createElement},
 * but also other implementations, like `React.createElement`, could be used.
 * Note, however, that this is only partially supported, as the typing don't match and the
 * props are not fully compatible.
 * @returns The root element of the tree containing all children.
 *
 * @public
 */
export declare function parseSjdon<T>([type, ...rest]: SjdonElement, create: CreateElementFunction<T>): T;

export declare type Primitive = string | number | bigint | boolean | symbol | null | undefined;

/**
 * The Props which a SuiWeb {@link Fiber} expects.
 */
export declare type Props = {
    /**
     * A unique key to differentiate the element between its siblings.
     * This should always be set when the number of elements is dynamic,
     * e.g., when using {@link Array.map} to create elements.
     */
    key?: string | number | null;
    /**
     * The style of the element.
     * @see {@link StyleProp}
     */
    style?: StyleProp;
    /**
     * Children must not be passed in the props, as they will be overwritten.
     * They should be specified as child elements in a represenation like `SJDON` or `JSX`.
     */
    children?: never;
} & Partial<Omit<HTMLElement, 'style' | 'children'>> & Record<string, unknown>;

/**
 * Renders the given fiber and its children to the DOM in the given container.
 * Note that all children of the container will be removed from
 * the DOM, before the fiber and its children are rendered.
 * @param fiber - The fiber which should be rendered.
 * @param container - The container in which the fiber should be rendered.
 *
 * @public
 */
export declare function render(fiber: Fiber, container: HTMLElement): void;

/**
 * A `SjdonElement` is an array containing at least one element.
 * The first element is of type {@link SjdonElementType} and specifies the type of the `SjdonElement`.
 * The other elements are either children or props of the element.
 * Chidren can be either a complete `SjdonElement` or a {@link Primitive}.
 * Props are always an object of type {@link Props}.
 * @example
 * ```typescript
 * // a heading 1 with no content
 * const minimalElement: SjdonElement = ['h1']
 * // a div containing a text and a paragraph
 * const elementWithChildren: SjdonElement = ['div', 'Test', ['p', 'Hello World!']]
 * // a button with specified onclick props and a text child.
 * const elementWithProps: SjdonElement = [
 *   'button',
 *   { onclick: () => console.log('Button clicked!') },
 *   'Click me!'
 * ]
 * ```
 */
export declare type SjdonElement = [SjdonElementType, ...(SjdonElementOrPrimitive | Props)[]];

/**
 * A `SjdonElementFunction` takes in props as a parameter and returns a {@link SjdonElement}.
 * @param props The props of the element. Children are automatically passed via the reserved `children` property.
 */
export declare type SjdonElementFunction<T = Record<string, unknown>> = (props?: T & {
    /**
     * The children of this functional element are automatically passed via this property.
     */
    children?: SjdonElementOrPrimitive[];
}) => SjdonElement;

/**
 * A `SjdonElementOrPrimitive` is either a {@link SjdonElement} or a {@link Primitive}.
 */
export declare type SjdonElementOrPrimitive = SjdonElement | Primitive;

/**
 * The type of a {@link SjdonElement}, which is specified in the first element of the array.
 * It can either be a HTML tag or a {@link SjdonElementFunction}.
 */
export declare type SjdonElementType = keyof HTMLElementTagNameMap | SjdonElementFunction;

/**
 * A `StaticFiber` represents a static element in the DOM. It does not contain
 * a function and thus can't use hooks, so it will never trigger a re-render.
 * It is completely defined by its `type`, `props` and `children`.
 * Its `domNode` will be assigned when it is rendered to the DOM.
 */
export declare type StaticFiber = {
    /**
     * The type of the static fiber.
     * It is either a html tag or a custom tag for text or placeholder nodes.
     */
    type: StaticFiberType;
    /**
     * The props of the static fiber. These will be added to them DOM node when it is rendered.
     * There are special props like `key` which serve their custom purpose and are not added to the DOM node.
     * @see {@link isNormalProp}
     */
    props: Readonly<Props>;
    /**
     * The children of the fiber are stored in a map where every child has a unique key.
     * If no `key` is provided in the `props` of the corresponding child, a default key is used.
     */
    children: Map<string, Fiber>;
    /**
     * The reference to the DOM node which this fiber represents.
     * Is only set when the fiber is rendered.
     */
    domNode?: HTMLElement | Text | undefined;
};

/**
 * The possible type of a {@link StaticFiber}.
 * Fibers with type `TEXT_NODE` or `PLACEHOLDER_NODE` will not be rendered
 * to the dom directly, but are treated specially instead.
 */
export declare type StaticFiberType = keyof HTMLElementTagNameMap | 'TEXT_NODE' | 'PLACEHOLDER_NODE';

/**
 * The `StyleProp` is usally passed as the `style` property of the props.
 * It can either be:
 * - a CSS string which is set directly to style attribute.
 * - an object containing CSS properties in camelCase.
 * - an array of objects containing CSS properties in camcelCase.
 */
export declare type StyleProp = string | Partial<CSSStyleDeclaration> | Partial<CSSStyleDeclaration>[];

/**
 * The function `useEffect` can be used in a functional component to execute an action,
 * after a component has been rendered. By specifying `dependencies`, calling the function
 * can be further restricted, to only call `action` under specific contidtions.
 * @param action - The action to execute after rendering the component.
 * @param dependencies - Defines the dependencies that decide on execution of `action`.
 * `action` will only be called if any of the value in the dependencies has changed
 * since the last render of the component.
 * Pass an empty array (`[]`) to only run `action` on the first render.
 * Pass `undefined` (or leave away the parameter) to run `action` on every render.
 * @example
 * ```tsx
 * const Counter = () => {
 *     const [count, setCount] = useState(0)
 *
 *     // `action` is called after every render.
 *     useEffect(() => console.log('Counter changed.')) // no dependencies defined
 *
 *     // `action` is called after every render, if the value of `count`
 *     // changed since the last render.
 *     useEffect(() => console.log('Counter changed.'), [count]) // specific dependency defined
 *
 *     // `action` is called only after the first render.
 *     useEffect(() => console.log('Counter changed.'), []) // empty array dependency
 *
 *     return <button onClick={() => setCount(count + 1)}>{`Count: ${count}`}</button>
 * }
 * ```
 *
 * @public
 */
export declare function useEffect(action: () => void, dependencies?: unknown[]): void;

/**
 * The function `useState` can be used inside a functional component to capture
 * state between re-rerenders. State values should never be mutated directly,
 * but always updated via the returned `setState` function (2nd element in the array).
 * This will trigger a re-render of the `FunctionalFiber` and its subtree (children).
 * @param initialValue - The initial value the state should have.
 * @returns An array containing the `state` as the first element and
 * the `setState` function as the second element.
 * @example
 * ```tsx
 * const Counter = () => {
 *     const [count, setCount] = useState(0)
 *     return <button onClick={() => setCount(count + 1)}>{`Count: ${count}`}</button>
 * }
 * ```
 *
 * @public
 */
export declare function useState<T>(initialValue: T): [T, (newValue: T) => void];

export { }

import { type Primitive } from './utils';
/**
 * A `Fiber` can be either a {@link StaticFiber} or a {@link FunctionalFiber}.
 */
export type Fiber = StaticFiber | FunctionalFiber;
/**
 * A `StaticFiber` represents a static element in the DOM. It does not contain
 * a function and thus can't use hooks, so it will never trigger a re-render.
 * It is completely defined by its `type`, `props` and `children`.
 * Its `domNode` will be assigned when it is rendered to the DOM.
 */
export type StaticFiber = {
    /**
     * The type of the static fiber.
     * It is either a html tag or a custom tag for text or placeholder nodes.
     */
    type: StaticFiberType;
    /**
     * The props of the static fiber. These will be added to them DOM node when it is rendered.
     * There are special props like `key` which serve their custom purpose and are not added to the DOM node.
     * @see {@link isNormalProp}
     */
    props: Readonly<Props>;
    /**
     * The children of the fiber are stored in a map where every child has a unique key.
     * If no `key` is provided in the `props` of the corresponding child, a default key is used.
     */
    children: Map<string, Fiber>;
    /**
     * The reference to the DOM node which this fiber represents.
     * Is only set when the fiber is rendered.
     */
    domNode?: HTMLElement | Text | undefined;
};
/**
 * The possible type of a {@link StaticFiber}.
 * Fibers with type `TEXT_NODE` or `PLACEHOLDER_NODE` will not be rendered
 * to the dom directly, but are treated specially instead.
 */
export type StaticFiberType = keyof HTMLElementTagNameMap | 'TEXT_NODE' | 'PLACEHOLDER_NODE';
/**
 * Determines if an object is of type {@link StaticFiber}.
 * @param object - The object to check.
 * @returns `true` if the object is of type {@link StaticFiber}.
 */
export declare function isStaticFiber(object: unknown): object is StaticFiber;
/**
 * A `FunctionalFiber` represents an element, which is generated by a function call.
 * This generator-function is stored in the property `fiberFunction` and when the component
 * is re-rendered, the `fiberFunction` is called with `functionalProps` as argument.
 * In the `fiberFunction`, hooks can be called, whose values are stored in the `memorizedStates` array.
 *
 * #### StaticFiber Properties
 * A `FunctionalFiber` contains all properties of a {@link StaticFiber}, but only as optionals.
 * The properties `type`, `props` and `children`, which define a {@link StaticFiber},
 * are only assigned when the component is unwrapped i.e., its `fiberFunction` is called.
 * This happens during rendering, when the `fiberFunction` is called. The returned {@link StaticFiber}
 * will be merged into the `FunctionalFiber` and provide these three properties.
 */
export type FunctionalFiber = {
    /**
     * The `fiberFunction` contains the information to generate the fiber.
     * It takes the `functionProps` as an argument, calls hooks and returns the generated `Fiber`.
     */
    fiberFunction: FiberFunction;
    /**
     * The `functionProps` are the props which are passed to the `fiberFunction`. Differently to the
     * normal `props`, these are not added to the DOM and only used inside of the `fiberFunction`.
     * The normal `props` will be defined by the `StaticFiber`, which will be returned from executing
     * the `fiberFunction`.
     * These will be the `props` that will be added to the DOM node.
     * @see {@link StaticFiber}
     */
    functionProps: Readonly<Props>;
    /**
     * The `memorizedStates` array contains all stored values of the component's hooks.
     */
    memorizedStates: unknown[];
} & Partial<StaticFiber>;
/**
 * The `FiberFunction` of a {@link FunctionalFiber}, which returns a {@link Fiber}.
 */
export type FiberFunction = (props?: Props) => Fiber;
/**
 * Determines if an object is of type {@link FunctionalFiber}.
 * @param object - The object to check.
 * @returns `true` if the object is of type {@link FunctionalFiber}.
 */
export declare function isFunctionalFiber(object: unknown): object is FunctionalFiber;
/**
 * The Props which a SuiWeb {@link Fiber} expects.
 */
export type Props = {
    /**
     * A unique key to differentiate the element between its siblings.
     * This should always be set when the number of elements is dynamic,
     * e.g., when using {@link Array.map} to create elements.
     */
    key?: string | number | null;
    /**
     * The style of the element.
     * @see {@link StyleProp}
     */
    style?: StyleProp;
    /**
     * Children must not be passed in the props, as they will be overwritten.
     * They should be specified as child elements in a represenation like `SJDON` or `JSX`.
     */
    children?: never;
} & Partial<Omit<HTMLElement, 'style' | 'children'>> & Record<string, unknown>;
/**
 * The `StyleProp` is usally passed as the `style` property of the props.
 * It can either be:
 * - a CSS string which is set directly to style attribute.
 * - an object containing CSS properties in camelCase.
 * - an array of objects containing CSS properties in camcelCase.
 */
export type StyleProp = string | Partial<CSSStyleDeclaration> | Partial<CSSStyleDeclaration>[];
/**
 * Determines if the given `propName` is a normal prop which should be directly added to
 * the DOM node, or if it serves a custom purpose.
 * Currently there are three special props, namely `children`, `style` and `key`.
 * @param propName - The name of the prop to check.
 * @returns `true` if the given prop is a normal prop.
 */
export declare function isNormalProp(propName: string): boolean;
/**
 * A function which creates elements from a `type`, `props` and `children`.
 * Can be used with SJDON, but also standards like JSX.
 * It is in the same format as the `React.createElement` function so it could possibly
 * be interchanged. But note that the typings don't match exactly,
 * e.g., `React.createElement` can't handle all values of {@link Props}.
 * @param type - The type can either be a HTML tag or a function, which returns an element.
 * @param props - The props of the element. If JSX is used instead of SJDON, it has to be made sure
 * that the "special props" like `style` or `key` overlap enough with the {@link Props}.
 * This should be the case for the properties `style` and `key`, but is not guaranteed for all props.
 * To provide basic functionality, also JSX `on<Event>` event handlers are supported.
 * @param children - The children of the element.
 * @returns The generated element.
 */
export type CreateElementFunction<T = Fiber> = (type: keyof HTMLElementTagNameMap | ((props?: Record<string, unknown>) => T), props: Props | null, ...children: (T | Primitive)[]) => T;
/**
 * The SuiWeb implementation of the generic {@link CreateElementFunction}, which creates a {@link Fiber}.
 * @param type - If the type is a HTML tag, a {@link StaticFiber} is created. If it's a function, a {@link FunctionalFiber} is created.
 * @param props - The props of the element.
 * @param children - The children of the element.
 * @returns The created {@link Fiber}, either a {@link StaticFiber} or a {@link FunctionalFiber}.
 *
 * @public
 */
export declare const createElement: CreateElementFunction<Fiber>;

import { createDomNode, updateDomNode } from './dom.js';
import { isFunctionalFiber, isStaticFiber } from './fiber.js';
import { prepareToUseHooks } from './hooks.js';
import { isHTMLElement } from './utils.js';
/**
 * Renders the given fiber and its children to the DOM in the given container.
 * Note that all children of the container will be removed from
 * the DOM, before the fiber and its children are rendered.
 * @param fiber - The fiber which should be rendered.
 * @param container - The container in which the fiber should be rendered.
 *
 * @public
 */
export function render(fiber, container) {
    while (container.firstChild)
        container.firstChild?.remove();
    // No previous version is specified, as it is the first render.
    renderFiber(fiber, container);
}
/**
 * Re-renders the given {@link FunctionalFiber} inside the given container.
 * This will create a copy of the fiber tree, re-evaluate the fiber's `fiberFunction`
 * and compare the newly generated fiber tree to the old one, applying all changes to the DOM.
 * @param fiber - The fiber which should be re-rendered.
 * @param container - The container to render the fiber in.
 */
export function rerenderFunctionalFiber(fiber, container) {
    // The previous version is just a copy of the functionalFiber, which should be re-rendered.
    // This copy contains all expanded static fibers with their children -
    // the whole fiber tree below this functional fiber.
    // While rendering, the functional fiber will recompute all its children with the fiberFunction.
    // By providing this copy, the previous versions children are still retained and
    // can be compared to the new children generated by the fiberFunction.
    const previousVersion = { ...fiber };
    renderFiber(fiber, container, previousVersion);
}
/**
 * Renders the fiber and its children to the DOM. If a `previousVersion` is
 * specified, the old and the new fiber-tree are compared and only the differences
 * between the two trees are changed in the DOM.
 * @param fiber - The fiber which should be rendered.
 * @param container - The container in which the fiber should be rendered.
 * @param previousVersion - The version of the fiber before the current render.
 * Is compared to `fiber` and only the differences between the two are changed in the DOM.
 * @param nextSibling - The next sibling in the container, to keep track of the correct order inside the DOM.
 */
function renderFiber(fiber, container, previousVersion, nextSibling) {
    // If the component is a functional fiber, execute its fiberFunction
    // to get the unwrapped StaticFiber properties merged into the same object.
    if (isFunctionalFiber(fiber))
        unwrapFunctionalFiber(fiber, container, previousVersion);
    // After unwrapping, the fiber must contain all properties of a static fiber.
    if (!isStaticFiber(fiber))
        throw new Error('Fiber did not contain all StaticFiber properties after unwrapping.');
    // If the fiber is a placeholder, just remove the previous version, if exists.
    if (fiber.type === 'PLACEHOLDER_NODE') {
        fiber.domNode = undefined;
        previousVersion?.domNode?.remove();
        return;
    }
    // Determines if the new fiber still has the same type as the old fiber.
    const areSameType = fiber && previousVersion && fiber.type === previousVersion.type;
    // Got a fiber with the same type in the tree, so just update the contents of the DOM node.
    if (areSameType)
        updateFiberInDom(fiber, container, previousVersion, nextSibling);
    // The types did not match, create new DOM node and remove previous DOM node.
    else
        replaceFiberInDom(fiber, container, previousVersion, nextSibling);
    expandChildFibers(fiber, previousVersion);
}
/**
 * Goes through all children of the `previousVersion` and the `fiber`.
 * If a child only exists in the `previousVersion`, it is removed from the DOM.
 * Otherwise, it calls {@link renderFiber} for every child and passes its previous version,
 * so that they can be compared and the correct adjustments in the DOM can be made.
 * @param fiber - The current version of the fiber, whose children should be expaneded.
 * @param previousVersion - The previous version of the fiber used for comparison.
 */
function expandChildFibers(fiber, previousVersion) {
    const currentChildren = fiber.children;
    const previousChildren = previousVersion?.children ?? new Map();
    // If the domNode of the container is not a HTMLElement, no children can be added to it.
    const container = fiber.domNode;
    if (!container || !isHTMLElement(container))
        return;
    // First, remove all previousChildren from the DOM, which don't exist in the currentChildren.
    previousChildren.forEach((previousChild, key) => {
        if (currentChildren.get(key) === undefined)
            previousChild.domNode?.remove();
    });
    // Go through all currentChildren and render them to the DOM.
    // The previous version is passed to determine the differences between the two versions.
    // The nextChildSibling is used to enforce the correct order in the DOM.
    // The order is reversed, to determine the nextChildSibling easily (to use insertBefore API).
    let nextChildSibling;
    const reversedChildren = Array.from(currentChildren.entries()).reverse();
    reversedChildren.forEach(([key, currentChild]) => {
        const previousChild = previousChildren.get(key);
        renderFiber(currentChild, container, previousChild, nextChildSibling);
        // Placeholder nodes are not rendered, so they are not used for the order inside the container
        if (currentChild.type !== 'PLACEHOLDER_NODE')
            nextChildSibling = currentChild;
    });
}
/**
 * Before unwrapping, a {@link FunctionalFiber} does not contain the
 * properties of a {@link StaticFiber} like `type`, `props` or `chidren`.
 * These will be only availble after unwrapping. To unwrap a {@link FunctionalFiber}
 * its `fiberFunction` is called. This process is repeated until a {@link StaticFiber}
 * is returned from the `fiberFunction`. The properties of the {@link StaticFiber} are
 * merged into the same reference of the {@link FunctionalFiber}.
 *
 * #### Hooks
 * To make the hooks work, {@link prepareToUseHooks} is called, before the `fiberFunction`
 * is executed. Additionally the `memorizedStates` array is copied from the `previousVersion`
 * so the state will not get lost.
 * @see {@link prepareToUseHooks}
 * @param fiber - The functional fiber which is unwrapped.
 * @param container - The container this fiber will be rendered in.
 * @param previousVersion - The previous version of the fiber, used to copy the `memorizedStates`.
 */
function unwrapFunctionalFiber(fiber, container, previousVersion) {
    // Copy memorizedStates from previousStates, or assign an empty array in case there is none
    fiber.memorizedStates = previousVersion?.memorizedStates ?? [];
    // Make fiber ready for hook calls.
    prepareToUseHooks(fiber.memorizedStates, () => rerenderFunctionalFiber(fiber, container));
    // Unwrap fibers until the fiberFunction returns a StaticFiber.
    let unwrappedFiber = fiber.fiberFunction(fiber.functionProps);
    while (isFunctionalFiber(unwrappedFiber))
        unwrappedFiber = unwrappedFiber.fiberFunction(unwrappedFiber.functionProps);
    // Merge all properties of the unwrappedFiber into the functional fiber.
    Object.assign(fiber, unwrappedFiber);
}
/**
 * Updates the DOM node of the `previousVersion` with the props of the new `fiber`.
 * If the order in the `container` has changed, the DOM node is reinserted at the correct position.
 */
function updateFiberInDom(fiber, container, previousVersion, nextSibling) {
    // Get DOM node from previous version
    const domNode = previousVersion.domNode;
    if (!domNode)
        throw new Error('Could not update fiber, previous domNode was not set.');
    fiber.domNode = domNode;
    // Update all props on DOM node
    updateDomNode(domNode, previousVersion?.props, fiber.props);
    // If the order has changed, the element has to be reinserted at correct position.
    // Note that insertBefore takes care of removing the element from the DOM before
    // re-inserting it, so it's not needed to remove it manually.
    if (nextSibling && domNode.nextSibling !== nextSibling?.domNode) {
        container.insertBefore(domNode, nextSibling?.domNode ?? null);
    }
}
/**
 * Creates a new DOM node for the `fiber` and inserts it at the correct position in the `container`.
 * Removes the DOM node of the `previousVersion` from the DOM.
 */
function replaceFiberInDom(fiber, container, previousVersion, nextSibling) {
    // Remove DOM node of the previous version from the DOM
    previousVersion?.domNode?.remove();
    // Create DOM node for new fiber
    const newDomNode = createDomNode(fiber);
    fiber.domNode = newDomNode;
    container.insertBefore(newDomNode, nextSibling?.domNode ?? null);
}
